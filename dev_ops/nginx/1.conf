upstream task{
    server 100.100.88.152:8097;
    check interval=30000 rise=2 fall=3 timeout=1000 type=http;
    check_http_send "GET /market/task/turnTask  HTTP/1.0\r\n\r\n";
    check_http_expect_alive http_2xx http_3xx;
}
server {
    location /market/task/ {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://task;
    }
}
# 实现的功能:
# 所有的请求中如果url中包含/market/task/的请求，都被分发到server 100.100.88.152:8097，这个ip和端口的服务器上。
# 很明显，如果task模块配置了server.context-path= /market/task 那么task模块下的所有web接口url地址都必须加上 /market/task， 那么在task模块下的web层所有接口都可以分发到server 100.100.88.152:8097上，不用考虑新增的Controller类上的路径和接口上定义的路径。

# 反之，如果没有配置server.context-path，或者server.context-path配置的没有区别性，比方说配置为 /market ，无法和其他模块区分开来，那么ngnix就没有办法分发出去。 这样模块下web层每次新增一个Controller类，为了能够让ngnix正常分发，不报404错误，需要在ngnix上对类的url地址进行配置，这是一件很麻烦的事情。所以server.context-path的规范配置很关键。